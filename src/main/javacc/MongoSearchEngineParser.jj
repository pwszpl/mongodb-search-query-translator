options {
    STATIC = false ;
    JDK_VERSION = "1.8";
    TOKEN_FACTORY = "mongo.search.transform.TokenFactory";
}

PARSER_BEGIN(MongoSearchEngineParser)
    package mongo.parser;

    import java.util.ArrayList;
    import mongo.search.transform.CriteriaTransformer;
    import mongo.search.util.StringUtil;
    import mongo.search.transform.TransformObject;
    import java.util.List;
    import java.util.function.Function;
    import mongo.search.transform.CriteriaTransformer;
    import mongo.search.transform.FiltersTransformer;

    public class MongoSearchEngineParser {
        private Function transformer = new FiltersTransformer();

        public void setCriteraMode(){
            this.transformer = new CriteriaTransformer();
        }

        public void setBSONMode(){
            this.transformer = new FiltersTransformer();
        }
    }
PARSER_END(MongoSearchEngineParser)

SKIP : {" " | "\n" | "\r" | "\r\n" }

TOKEN : { < IN : "IN" | "in" >}
TOKEN : { < NIN : "NIN" | "nin" >}
TOKEN : { < EXISTS: "EXISTS" | "exists" >}
TOKEN : { < L_PAR : "(" >}
TOKEN : { < R_PAR : ")" >}
TOKEN : { < AND : "&&" | "and" | "AND" > }
TOKEN : { < OR : "||" | "or" | "OR" >}
TOKEN : { < EQ : "=" >}
TOKEN : { < NE : "<>" | "!=" | "^=" >}
TOKEN : { < GT : ">" >}
TOKEN : { < LT : "<" >}
TOKEN : { < LE : "<=" >}
TOKEN : { < GE : ">=" >}
TOKEN : { < R_NUMBER : ("-")?<NUMBER> >}
TOKEN : { < NUMBER : <DIGITS> | <DIGITS> "." <DIGITS> | "." <DIGITS> >}
TOKEN : { < OBJ_FIELD : (["A"-"Z","a"-"z","0"-"9","."])+ > }
TOKEN : {  < STRING_LITERAL : "'"  (~["\n","\r","'"])*  "'"> }
TOKEN : { < #DIGITS : (["0"-"9"])+ > }

Object parse():
{
    Object result;
}
{
    result = OrExpression()
    <EOF>
    {return result;}
}

Object OrExpression():
{
    Object value;
    Object result;
    Token operator = null;
}
{
    value = AndExpression()
    {result = value;}
    (
        operator=<OR>
        value = AndExpression()
        {
            result = applyTransfromFunction(operator,result,value);
        }
    )*
    {return result;}
}

Object AndExpression():
{
    Object value;
    Object result;
    Token operator = null;
}
{
    value = LogicalExpression()
    {result = value;}
    (
        operator=<AND>
        value = LogicalExpression()
        {
            result = applyTransfromFunction(operator,result,value);
        }
    )*
    {return result;}
}

Object LogicalExpression():
{
    Object value;
    Token token;
}
{
    <L_PAR> value = OrExpression() <R_PAR>
    {return value;}
|
    value = FieldComparision()
    {return value;}
|
    value = OneArgumentFunction()
    {return value;}
}

Object OneArgumentFunction():
{
    Token operator;
    Token field;
}
{
    operator=<EXISTS> <L_PAR> field=<OBJ_FIELD> <R_PAR>
    {
        return applyTransfromFunction(operator,field);
    }
}

Object FieldComparision():
{
    Token operator;
    Token objField;
    Token numValue = null;
    Token strValue = null;
    Object ret = null;
}
{
    objField=<OBJ_FIELD> ret=evaluatFieldOperator(objField)
    {
        return ret;
    }
}

Object evaluatFieldOperator(Token field):
{
    Token operator;
    Token numValue = null;
    Token strValue = null;
    List<Object> inList = new ArrayList();
}
{
    (operator=<IN> | operator=<NIN> ) <L_PAR>
        (
       numValue=<R_NUMBER>
       { inList.add(numValue); }
       |
       strValue= <STRING_LITERAL>
       { inList.add(strValue); }
       )* <R_PAR>
    {
        return applyTransfromFunction(operator,field,inList);
    }
    |
    (operator=<GE> | operator=<LE> | operator=<EQ> | operator=<NE> | operator=<GT> | operator=<LT>) (numValue=<R_NUMBER> | strValue= <STRING_LITERAL> )
        {
            return applyTransfromFunction(operator,field,numValue,strValue);
        }
}

Object applyTransfromFunction(Token operator, Object... objects):
{
}
{
    {
      TransformObject object = new TransformObject(operator,objects);
      return transformer.apply(object);
    }
}